{
  "version": 3,
  "sources": ["../src/lib/excel-to-pdf.js", "../src/lib/utils/draw-borders.js", "../src/lib/utils/encodeCell.js", "../src/lib/utils/decodeCell.js", "../src/lib/utils/extractCellText.js"],
  "sourcesContent": ["// src/lib/excel-to-pdf.js\n\nimport ExcelJS from \"exceljs\";\nimport fs from \"fs\";\nimport { jsPDF } from \"jspdf\";\nimport { drawBorders } from \"./utils/draw-borders.js\";\nimport { encodeCell } from \"./utils/encodeCell.js\";\nimport { decodeCell } from \"./utils/decodeCell.js\";\nimport { extractCellText } from \"./utils/extractCellText.js\";\n\n/**\n * Converts an Excel file to a PDF document.\n * @param {string} inputFilePath Path to the input Excel file.\n * @param {string} outputFilePath Name of the output PDF file.\n * @param {boolean} enablePagination Whether to enable pagination (default: false)\n * @param {number} MAX_WIDTH_SIZE Maximum width size for the PDF (default: 14400)\n * @param {number} MAX_HEIGHT_SIZE Maximum height size for the PDF (default: 14400)\n * @param {number} MIN_WIDTH_SIZE Minimum width size for the PDF (default: 300)\n * @param {number} MIN_HEIGHT_SIZE Minimum height size for the PDF (default: 300)\n * @param {boolean} useMinLimit Whether to enforce minimum size limits (default: false)\n * @param {number} fixedAt Number of decimal places for numeric formatting (default: 2)\n */\nexport async function convertExcelToPdf({\n  inputFilePath,\n  outputFilePath,\n  enablePagination = false,\n  MAX_WIDTH_SIZE = 14400,\n  MAX_HEIGHT_SIZE = 14400,\n  // letter width in points\n  MIN_WIDTH_SIZE = 612,\n  // letter height in points\n  MIN_HEIGHT_SIZE = 792,\n  useMinLimit = false,\n  fixedAt = 2,\n}) {\n  // Check if file exists\n  if (!fs.existsSync(inputFilePath)) {\n    throw new Error(`Error: The file \"${inputFilePath}\" was not found.`);\n  }\n\n  // Create Workbook instance\n  const workbook = new ExcelJS.Workbook();\n\n  try {\n    // Read Excel file asynchronously\n    await workbook.xlsx.readFile(inputFilePath);\n\n    const worksheet = workbook.getWorksheet(1);\n\n    // Process data as before\n    const styledRows = [];\n    const totalRows = worksheet.rowCount;\n    const totalCols = worksheet.columnCount;\n    // Build merge map: { 'row-col': { range, startRow, startCol, endRow, endCol } }\n    const mergeMap = {};\n    if (worksheet._merges) {\n      Object.entries(worksheet._merges).forEach(([key, merge]) => {\n        const { top, left, bottom, right } = merge.model;\n        for (let r = top; r <= bottom; r++) {\n          for (let c = left; c <= right; c++) {\n            mergeMap[`${r}-${c}`] = {\n              range: `${top}-${left}:${bottom}-${right}`,\n              startRow: top,\n              startCol: left,\n              endRow: bottom,\n              endCol: right,\n            };\n          }\n        }\n      });\n    }\n    // Only add main cell of merge and skip secondary cells\n    for (let rowNumber = 1; rowNumber <= totalRows; rowNumber++) {\n      const row = worksheet.getRow(rowNumber);\n      const cells = [];\n      for (let colNumber = 1; colNumber <= totalCols; colNumber++) {\n        const key = `${rowNumber}-${colNumber}`;\n        // If cell is part of a merge and not the main one, skip it\n        if (\n          mergeMap[key] &&\n          (rowNumber !== mergeMap[key].startRow ||\n            colNumber !== mergeMap[key].startCol)\n        ) {\n          // Ensure secondary merge cells are empty\n          cells.push({\n            text: \"\",\n            style: {},\n            mergeInfo: null,\n            isSecondaryMergeCell: true,\n          });\n          continue;\n        }\n        // Only process the main cell of the merge\n        let cell = row.getCell(colNumber);\n        let text = extractCellText(cell, fixedAt);\n\n        let style = cell.style || {};\n        let mergeInfo = null;\n        if (mergeMap[key]) {\n          mergeInfo = mergeMap[key];\n        }\n        cells.push({ text, style, mergeInfo });\n      }\n      styledRows.push(cells);\n    }\n\n    // Adjust references before calling decodeCell\n    Object.entries(mergeMap).forEach(([key, mergeInfo]) => {\n      const startCell = encodeCell(mergeInfo.startRow, mergeInfo.startCol);\n      const endCell = encodeCell(mergeInfo.endRow, mergeInfo.endCol);\n      mergeInfo.range = `${startCell}:${endCell}`;\n    });\n\n    // Calculate dynamic table and page dimensions\n    const defaultFontSize = 12;\n    let rowHeight = 20; // Make it let so we can scale it later\n    // Create temporary jsPDF instance for text width calculation\n    const tempDoc = new jsPDF({\n      unit: \"pt\",\n      format: \"a4\",\n    });\n    const padding = 10;\n    const extraSpace = 10;\n    const colWidths = Array(totalCols).fill(padding);\n\n    // Calculate column widths considering all rows, including the header\n    styledRows.forEach((row) => {\n      row.forEach((cell, idx) => {\n        if (cell.isSecondaryMergeCell) {\n          return; // Ignore secondary merge cells\n        }\n\n        const text = cell.text || \"\";\n        const size = cell.style.font?.size || defaultFontSize;\n        let fontStyle = \"normal\";\n        if (cell.style.font?.bold && cell.style.font?.italic) {\n          fontStyle = \"bolditalic\";\n        } else if (cell.style.font?.bold) {\n          fontStyle = \"bold\";\n        } else if (cell.style.font?.italic) {\n          fontStyle = \"italic\";\n        }\n\n        tempDoc.setFont(\"helvetica\", fontStyle);\n        tempDoc.setFontSize(size);\n        const textWidth = tempDoc.getTextWidth(text) + padding + extraSpace;\n\n        if (cell.mergeInfo) {\n          // If cell is part of a merge, calculate total width of merged columns\n          const { startCol, endCol } = cell.mergeInfo;\n          const mergedWidth = colWidths\n            .slice(startCol - 1, endCol)\n            .reduce((sum, w) => sum + w, 0);\n\n          // If total width of merged columns is less than required for the text, adjust it\n          if (mergedWidth < textWidth) {\n            const extraWidth = textWidth - mergedWidth;\n            const numCols = endCol - startCol + 1;\n            const additionalWidthPerCol = extraWidth / numCols;\n\n            for (let i = startCol - 1; i < endCol; i++) {\n              colWidths[i] += additionalWidthPerCol;\n            }\n          }\n        } else {\n          // If not a merged cell, adjust the width of the individual column\n          if (textWidth > colWidths[idx]) {\n            colWidths[idx] = textWidth;\n          }\n        }\n      });\n    });\n    const tableWidth = colWidths.reduce((sum, w) => sum + w, 0);\n    const tableHeight = totalRows * rowHeight + 10;\n    const margin = 50;\n    let pageWidth = tableWidth + margin * 2;\n    let pageHeight = tableHeight + margin * 2 + 40;\n\n    // Apply minimum limits if requested\n    if (useMinLimit) {\n      if (pageWidth < MIN_WIDTH_SIZE) {\n        pageWidth = MIN_WIDTH_SIZE;\n        console.log(`Page width increased to minimum: ${MIN_WIDTH_SIZE} units`);\n      }\n      if (pageHeight < MIN_HEIGHT_SIZE) {\n        pageHeight = MIN_HEIGHT_SIZE;\n        console.log(\n          `Page height increased to minimum: ${MIN_HEIGHT_SIZE} units`\n        );\n      }\n    }\n\n    // Apply maximum limits - handle large documents intelligently\n    if (pageWidth > MAX_WIDTH_SIZE || pageHeight > MAX_HEIGHT_SIZE) {\n      if (pageHeight > MAX_HEIGHT_SIZE && !enablePagination) {\n        // If height exceeds limit, enable pagination and use ideal table width\n        console.warn(\n          \"Document height too large, enabling pagination automatically\"\n        );\n        enablePagination = true;\n\n        // Keep the ideal table width (up to MAX_WIDTH_SIZE) for better readability\n        if (pageWidth > MAX_WIDTH_SIZE) {\n          pageWidth = MAX_WIDTH_SIZE;\n          console.log(\n            `Table width capped at ${MAX_WIDTH_SIZE} units for jsPDF compatibility`\n          );\n        }\n\n        // Use standard letter height for pagination\n        pageHeight = MIN_HEIGHT_SIZE;\n      } else if (\n        pageWidth > MAX_WIDTH_SIZE &&\n        pageHeight <= MAX_HEIGHT_SIZE &&\n        !enablePagination\n      ) {\n        // If only width exceeds limit, cap it at MAX_WIDTH_SIZE\n        pageWidth = MAX_WIDTH_SIZE;\n        console.log(\n          `Table width capped at ${MAX_WIDTH_SIZE} units for jsPDF compatibility`\n        );\n      } else if (enablePagination) {\n        // If pagination is already enabled, use standard letter size for height\n        // but preserve table width up to MAX_WIDTH_SIZE\n        if (pageWidth > MAX_WIDTH_SIZE) {\n          pageWidth = MAX_WIDTH_SIZE;\n          console.log(\n            `Table width capped at ${MAX_WIDTH_SIZE} units for jsPDF compatibility`\n          );\n        }\n        pageHeight = MIN_HEIGHT_SIZE;\n      }\n\n      console.log(`Final page dimensions: ${pageWidth}x${pageHeight}`);\n    }\n\n    // Extract images from worksheet\n    const images = [];\n    worksheet.getImages().forEach((img) => {\n      const range = img.range;\n      const ext = range.ext;\n      const tl = range?.tl;\n      if (!tl || tl.col == null || tl.row == null) return;\n      const media = workbook.getImage(img.imageId);\n      if (!media?.buffer) return;\n      images.push({ buffer: media.buffer, ext, tl });\n    });\n\n    // Generate PDF with dynamic size\n    const doc = new jsPDF({\n      orientation: pageWidth > pageHeight ? \"landscape\" : \"portrait\",\n      unit: \"pt\",\n      format: [pageWidth, pageHeight],\n    });\n\n    // Draw images first (jsPDF has limited image support)\n    images.forEach(({ tl, ext, buffer }) => {\n      try {\n        const colIndex = tl.nativeCol || 0;\n        const rowIndex = tl.nativeRow || 0;\n        const imgX =\n          margin + colWidths.slice(0, colIndex).reduce((sum, w) => sum + w, 0);\n        const imgY = margin + rowIndex * rowHeight;\n        const ptsPerPx = 0.75;\n        const imgWidthPts = (ext?.width || 0) * ptsPerPx;\n        const imgHeightPts = (ext?.height || 0) * ptsPerPx;\n\n        // Convert buffer to base64 for jsPDF\n        const base64String = buffer.toString(\"base64\");\n        const dataURL = `data:image/png;base64,${base64String}`;\n\n        doc.addImage(dataURL, \"PNG\", imgX, imgY, imgWidthPts, imgHeightPts);\n      } catch (imageError) {\n        console.warn(\"Could not add image:\", imageError.message);\n      }\n    });\n\n    let y = margin;\n    const startX = margin;\n\n    // Process all rows\n    styledRows.forEach((row, rowIdx) => {\n      let x = startX; // Ensure x is initialized before use\n      // Check if content exceeds page height\n      if (enablePagination && y + rowHeight > pageHeight - margin) {\n        doc.addPage(); // Add new page\n        y = margin; // Reset vertical position\n      }\n\n      // For very wide tables, we'll just use the original logic but with smaller cells if needed\n      row.forEach((cell, i) => {\n        // Check if cell is part of a merge\n        let isMerged = false;\n        let isMainMergeCell = false;\n        let mergeCols = 1;\n        let mergeRows = 1;\n\n        if (cell.mergeInfo) {\n          // Calculate merge range\n          const [start, end] = cell.mergeInfo.range.split(\":\");\n          const startCell = decodeCell(start);\n          const endCell = decodeCell(end);\n          mergeCols = endCell.col - startCell.col + 1;\n          mergeRows = endCell.row - startCell.row + 1;\n          isMerged = true;\n\n          // Only draw if we are in the main cell of the merge (top-left)\n          if (rowIdx + 1 === startCell.row && i + 1 === startCell.col) {\n            isMainMergeCell = true;\n          }\n        }\n\n        // If it's a merged cell but not the main one, skip drawing\n        if (isMerged && !isMainMergeCell) {\n          x += colWidths[i] || 10 * 6 + padding;\n          return;\n        }\n\n        // Draw cell (merged or normal)\n        if (isMerged && isMainMergeCell) {\n          // Merged cell - calculate combined dimensions\n          const mergedWidth = colWidths\n            .slice(i, i + mergeCols)\n            .reduce((sum, w) => sum + w, 0);\n          const mergedHeight = rowHeight * mergeRows;\n\n          // Background\n          if (\n            cell.style.fill &&\n            cell.style.fill.fgColor &&\n            cell.style.fill.fgColor.argb\n          ) {\n            const hex = cell.style.fill.fgColor.argb.slice(2);\n            doc.setFillColor(`#${hex}`);\n            doc.rect(x, y, mergedWidth, mergedHeight, \"F\");\n          }\n\n          // Font and text configuration\n          const fontSize = cell.style.font?.size || 12;\n          const isBold = cell.style.font?.bold;\n          const isItalic = cell.style.font?.italic;\n\n          let fontStyle = \"normal\";\n          if (isBold && isItalic) fontStyle = \"bolditalic\";\n          else if (isBold) fontStyle = \"bold\";\n          else if (isItalic) fontStyle = \"italic\";\n\n          doc.setFont(\"helvetica\", fontStyle);\n          doc.setFontSize(fontSize);\n\n          // Text color\n          const textColor = cell.style.font?.color?.argb\n            ? `#${cell.style.font.color.argb.slice(2)}`\n            : \"#000000\";\n          doc.setTextColor(textColor);\n\n          // Text positioning and alignment\n          const text = cell.text || \"\";\n          const align = cell.style.alignment?.horizontal || \"left\";\n          const textY = y + mergedHeight / 2 + fontSize / 3; // Centered vertically\n\n          if (align === \"center\") {\n            doc.text(text, x + mergedWidth / 2, textY, { align: \"center\" });\n          } else if (align === \"right\") {\n            doc.text(text, x + mergedWidth - 2, textY, { align: \"right\" });\n          } else {\n            doc.text(text, x + 2, textY);\n          }\n\n          // Borders\n          const borders = cell.style.border || {};\n          drawBorders(doc, x, y, mergedWidth, mergedHeight, borders);\n\n          // Update x correctly so cells align\n          x += colWidths[i] || 10 * 6 + padding; // Increment x by total width of merged cell\n        } else {\n          // Normal cell (not merged)\n          const cellWidth = colWidths[i] || 10 * 6 + padding;\n\n          // Background\n          if (\n            cell.style.fill &&\n            cell.style.fill.fgColor &&\n            cell.style.fill.fgColor.argb\n          ) {\n            const hex = cell.style.fill.fgColor.argb.slice(2);\n            doc.setFillColor(`#${hex}`);\n            doc.rect(x, y, cellWidth, rowHeight, \"F\");\n          }\n\n          // Font and text configuration\n          const fontSize = cell.style.font?.size || 12;\n          const isBold = cell.style.font?.bold;\n          const isItalic = cell.style.font?.italic;\n\n          let fontStyle = \"normal\";\n          if (isBold && isItalic) fontStyle = \"bolditalic\";\n          else if (isBold) fontStyle = \"bold\";\n          else if (isItalic) fontStyle = \"italic\";\n\n          doc.setFont(\"helvetica\", fontStyle);\n          doc.setFontSize(fontSize);\n\n          // Text color\n          const textColor = cell.style.font?.color?.argb\n            ? `#${cell.style.font.color.argb.slice(2)}`\n            : \"#000000\";\n          doc.setTextColor(textColor);\n\n          // Text positioning and alignment\n          const text = cell.text || \"\";\n          const align = cell.style.alignment?.horizontal || \"left\";\n          const textY = y + rowHeight / 2 + fontSize / 3; // Centered vertically\n\n          if (align === \"center\") {\n            doc.text(text, x + cellWidth / 2, textY, { align: \"center\" });\n          } else if (align === \"right\") {\n            doc.text(text, x + cellWidth - 2, textY, { align: \"right\" });\n          } else {\n            doc.text(text, x + 2, textY);\n          }\n\n          // Borders\n          const borders = cell.style.border || {};\n          drawBorders(doc, x, y, cellWidth, rowHeight, borders);\n\n          // Update x correctly so cells align\n          x += cellWidth; // Increment x by total width of normal cell\n        }\n      });\n      y += rowHeight;\n    });\n\n    // Save PDF\n    doc.save(outputFilePath);\n  } catch (error) {\n    throw new Error(`Error processing Excel file: ${error.message}`);\n  }\n}\n", "/**\n * Draws borders around a cell in a PDF document using jsPDF\n * @param {jsPDF} doc - The jsPDF document instance\n * @param {number} x - The x coordinate of the cell\n * @param {number} y - The y coordinate of the cell\n * @param {number} width - The width of the cell\n * @param {number} height - The height of the cell\n * @param {Object} borders - The border styles object containing top, left, bottom, right properties\n */\nexport function drawBorders(doc, x, y, width, height, borders) {\n  if (!borders) return;\n\n  const sides = [\"top\", \"left\", \"bottom\", \"right\"];\n  \n  sides.forEach((side) => {\n    const border = borders[side];\n    if (border && border.style && border.style.toLowerCase() !== \"none\") {\n      const color = border.color?.argb \n        ? `#${border.color.argb.slice(2)}` \n        : \"#000000\";\n      \n      doc.setDrawColor(color);\n      doc.setLineWidth(1);\n\n      switch (side) {\n        case \"top\":\n          doc.line(x, y, x + width, y);\n          break;\n        case \"left\":\n          doc.line(x, y, x, y + height);\n          break;\n        case \"bottom\":\n          doc.line(x, y + height, x + width, y + height);\n          break;\n        case \"right\":\n          doc.line(x + width, y, x + width, y + height);\n          break;\n      }\n    }\n  });\n}", "/**\n * Converts row and column numbers to Excel-style cell references\n * @param {number} row - The row number (1-based)\n * @param {number} col - The column number (1-based)\n * @returns {string} Excel cell reference (e.g. 'A1', 'B2', 'AA10', etc.)\n * @example\n * encodeCell(1, 1) // returns 'A1'\n * encodeCell(2, 27) // returns 'AA2'\n */\nexport function encodeCell(row, col) {\n  let colLetters = \"\";\n  while (col > 0) {\n    const remainder = (col - 1) % 26;\n    colLetters = String.fromCharCode(65 + remainder) + colLetters;\n    col = Math.floor((col - 1) / 26);\n  }\n  return `${colLetters}${row}`;\n}\n", "/**\n * Decodes Excel-style cell references (e.g. 'A1') to row and column numbers\n * @param {string} ref - The cell reference (e.g. 'A1', 'B2', etc.)\n * @returns {Object} An object containing row and column numbers\n * @throws {Error} If the cell reference is invalid\n */\nexport function decodeCell(ref) {\n  const match = ref.match(/^([A-Z]+)(\\d+)$/);\n  if (!match) {\n    throw new Error(`Invalid cell reference: ${ref}`);\n  }\n  const colLetters = match[1];\n  const row = parseInt(match[2], 10);\n  // Convierte letras de columna a n\u00FAmero\n  let col = 0;\n  for (let i = 0; i < colLetters.length; i++) {\n    col *= 26;\n    col += colLetters.charCodeAt(i) - 64;\n  }\n  return { row, col };\n}\n", "/**\n * Extracts text from an Excel cell, handling different value types and formatting\n * @param {Object} cell - The Excel cell object\n * @param {number} fixedAt - Number of decimal places for numeric formatting (default: 2)\n * @returns {string} The formatted text value\n */\nexport function extractCellText(cell, fixedAt = 2) {\n  if (cell.value == null) {\n    return \"\";\n  }\n\n  // Handle object values (richText, formulas, etc.)\n  if (typeof cell.value === \"object\") {\n    // Handle formulas with calculated results\n    if (cell.value.result !== undefined) {\n      // If the formula has a calculated result, use it\n      const result = cell.value.result;\n      \n      // Format the result based on its type\n      if (typeof result === \"number\") {\n        const format = cell.numFmt || \"\";\n        \n        if (format.includes('0.00') || format.includes('#.##') || format.includes('0.0')) {\n          const decimalMatch = format.match(/\\.0+/);\n          const decimalPlaces = decimalMatch ? decimalMatch[0].length - 1 : fixedAt;\n          return result.toFixed(decimalPlaces);\n        }\n        \n        // For numbers with natural decimals, preserve them\n        if (result % 1 !== 0) {\n          return result.toString();\n        }\n        \n        return result.toString();\n      }\n      \n      return String(result);\n    }\n    \n    // Handle richText\n    if (cell.value.richText && Array.isArray(cell.value.richText)) {\n      return cell.value.richText\n        .map(part => part.text || \"\")\n        .join(\"\");\n    }\n    \n    // Handle hyperlinks\n    if (cell.value.hyperlink && cell.value.text) {\n      return cell.value.text;\n    }\n    \n    // Handle other object types with text property\n    if (cell.value.text) {\n      return cell.value.text;\n    }\n    \n    // For formulas without results, try different approaches\n    if (cell.value.formula) {\n      // Check if there's a cached result or error value\n      if (cell.value.error) {\n        return `#${cell.value.error.toUpperCase()}`;\n      }\n      \n      // Use cell.text if available for formulas (often contains calculated value)\n      if (cell.text && cell.text !== \"\") {\n        return cell.text;\n      }\n      \n      // If no result available, show the formula\n      return `=${cell.value.formula}`;\n    }\n    \n    // Handle shared formulas without results\n    if (cell.value.sharedFormula) {\n      // Use cell.text if available\n      if (cell.text && cell.text !== \"\") {\n        return cell.text;\n      }\n      // Try to show a placeholder or the formula reference\n      return \"0\"; // Default value for unresolved shared formulas\n    }\n    \n    // If it's an empty object or unrecognized structure, return empty string\n    if (Object.keys(cell.value).length === 0) {\n      return \"\";\n    }\n    \n    // Fallback for other objects (but avoid showing complex formula objects)\n    return \"\";\n  }\n\n  // Handle numeric values\n  if (typeof cell.value === \"number\") {\n    try {\n      const format = cell.numFmt || \"\";\n      \n      // Check if the format explicitly defines decimal places\n      if (format.includes('0.00') || format.includes('#.##') || format.includes('0.0')) {\n        const decimalMatch = format.match(/\\.0+/);\n        const decimalPlaces = decimalMatch ? decimalMatch[0].length - 1 : fixedAt;\n        return cell.value.toFixed(decimalPlaces);\n      }\n      \n      // Check if cell.text shows decimals but preserve our decimal formatting logic\n      if (cell.text && cell.text.includes('.')) {\n        // Use cell.text but only if it's reasonable (not a formula display)\n        if (!cell.text.startsWith('=') && !cell.text.includes('(')) {\n          return cell.text;\n        }\n      }\n      \n      // For numbers with natural decimals, preserve them\n      if (cell.value % 1 !== 0) {\n        return cell.value.toString();\n      }\n      \n      // For whole numbers, keep as integer unless format suggests decimals\n      return cell.value.toString();\n    } catch (e) {\n      return String(cell.value);\n    }\n  }\n\n  // Check cell.text for other types (like dates, strings with special formatting)\n  if (cell.text && cell.text !== \"\") {\n    return cell.text;\n  }\n\n  // Handle all other types (strings, booleans, dates, etc.)\n  if (typeof cell.value === \"string\") {\n    // Handle ISO date strings\n    if (cell.value.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/)) {\n      try {\n        const date = new Date(cell.value);\n        // Return formatted date (you can customize this format)\n        return date.toLocaleDateString();\n      } catch (e) {\n        return cell.value;\n      }\n    }\n  }\n  \n  return String(cell.value);\n}\n"],
  "mappings": "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",
  "names": ["ExcelJS", "fs", "jsPDF", "drawBorders", "doc", "x", "y", "width", "height", "borders", "side", "_a", "border", "color", "encodeCell", "row", "col", "colLetters", "remainder", "decodeCell", "ref", "match", "colLetters", "row", "col", "i", "extractCellText", "cell", "fixedAt", "result", "format", "decimalMatch", "decimalPlaces", "part", "convertExcelToPdf", "inputFilePath", "outputFilePath", "enablePagination", "MAX_WIDTH_SIZE", "MAX_HEIGHT_SIZE", "MIN_WIDTH_SIZE", "MIN_HEIGHT_SIZE", "useMinLimit", "fixedAt", "fs", "workbook", "ExcelJS", "worksheet", "styledRows", "totalRows", "totalCols", "mergeMap", "key", "merge", "top", "left", "bottom", "right", "r", "c", "rowNumber", "row", "cells", "colNumber", "cell", "text", "extractCellText", "style", "mergeInfo", "startCell", "encodeCell", "endCell", "defaultFontSize", "rowHeight", "tempDoc", "jsPDF", "padding", "extraSpace", "colWidths", "idx", "_a", "_b", "_c", "_d", "_e", "size", "fontStyle", "textWidth", "startCol", "endCol", "mergedWidth", "sum", "w", "extraWidth", "numCols", "additionalWidthPerCol", "i", "tableWidth", "tableHeight", "margin", "pageWidth", "pageHeight", "images", "img", "range", "ext", "tl", "media", "doc", "buffer", "colIndex", "rowIndex", "imgX", "imgY", "ptsPerPx", "imgWidthPts", "imgHeightPts", "dataURL", "imageError", "y", "startX", "rowIdx", "x", "_f", "_g", "_h", "_i", "_j", "_k", "_l", "isMerged", "isMainMergeCell", "mergeCols", "mergeRows", "start", "end", "decodeCell", "mergedHeight", "hex", "fontSize", "isBold", "isItalic", "textColor", "align", "textY", "borders", "drawBorders", "cellWidth", "error"]
}
